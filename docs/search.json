[
  {
    "objectID": "simeta.html",
    "href": "simeta.html",
    "title": "Resimulate random effect variates on demand",
    "section": "",
    "text": "library(mrgsolve)\nlibrary(dplyr)\noptions(mrgsolve.soloc=\"build\")"
  },
  {
    "objectID": "simeta.html#simeps-example",
    "href": "simeta.html#simeps-example",
    "title": "Resimulate random effect variates on demand",
    "section": "simeps example",
    "text": "simeps example\n\nIn this example, we want to re-simulate the residual error variate to make sure we have a concentration that is positive.\nWe set up a loop that looks like the simeta example, but we work in $TABLE this time because we are calculating CP.\n\n\ncode <- '\n$PARAM CL = 1, V = 20, FLAG=0\n\n$SIGMA 50\n\n$PKMODEL cmt=\"CENT\"\n\n$TABLE\ncapture CP = CENT/V + EPS(1);\n\nint i = 0;\nwhile(CP < 0 && FLAG > 0) {\n  if(++i > 100) {\n    mrg::report(\"Problem simulating positive CP\");\n    break;\n  }\n  simeps();\n  CP = CENT/V + EPS(1);\n}\n\n'\n\n\nmod <- mcode_cache(\"simeps\", code)\n\nLoading model from cache.\n\n\n\nSimulate without simeps\n\nsystem.time({\n  out <- mod %>% ev(amt=100) %>% mrgsim(end=48)\n  sum <- summary(out)\n})\n\n.    user  system elapsed \n.   0.007   0.000   0.007\n\nprint(sum)\n\n.        ID         time            CENT              CP          \n.  Min.   :1   Min.   : 0.00   Min.   :  0.00   Min.   :-15.8385  \n.  1st Qu.:1   1st Qu.:11.25   1st Qu.: 15.93   1st Qu.: -0.8774  \n.  Median :1   Median :23.50   Median : 29.38   Median :  3.5281  \n.  Mean   :1   Mean   :23.52   Mean   : 37.47   Mean   :  3.3644  \n.  3rd Qu.:1   3rd Qu.:35.75   3rd Qu.: 54.21   3rd Qu.:  6.9420  \n.  Max.   :1   Max.   :48.00   Max.   :100.00   Max.   : 21.0483\n\n\nNegative concentrations are simulated when we don’t call the simeps loop.\n\n\nSimulate with simeps\n\nsystem.time({\n  out <- mod %>% ev(amt=100) %>% mrgsim(end=48, param=list(FLAG=1))\n  sum <- summary(out)\n})\n\n   user  system elapsed \n  0.035   0.001   0.036 \n\nprint(sum)\n\n       ID         time            CENT              CP          \n Min.   :1   Min.   : 0.00   Min.   :  0.00   Min.   : 0.01046  \n 1st Qu.:1   1st Qu.:11.25   1st Qu.: 15.93   1st Qu.: 3.12675  \n Median :1   Median :23.50   Median : 29.38   Median : 6.38530  \n Mean   :1   Mean   :23.52   Mean   : 37.47   Mean   : 6.99933  \n 3rd Qu.:1   3rd Qu.:35.75   3rd Qu.: 54.21   3rd Qu.:11.50485  \n Max.   :1   Max.   :48.00   Max.   :100.00   Max.   :17.46165  \n\n\nBetter … all concentrations are positive."
  },
  {
    "objectID": "events.html",
    "href": "events.html",
    "title": "Work with event objects",
    "section": "",
    "text": "Event objects are simple ways to implement PK dosing events into your model simulation.\nLet’s illustrate event objects with a one-compartment, PK model. We read this model from the mrgsolve internal model library."
  },
  {
    "objectID": "events.html#combine-to-create-a-data-set",
    "href": "events.html#combine-to-create-a-data-set",
    "title": "Work with event objects",
    "section": "Combine to create a data set",
    "text": "Combine to create a data set\nWe can take several event objects and combine them into a single simulation data frame with the as_data_set function.\n\ne1 <- ev(amt=100, ii=24, addl=6,  ID=1:5)\ne2 <- ev(amt=50,  ii=12, addl=13, ID=1:3)\ne3 <- ev(amt=200, ii=24, addl=2,  ID=1:2)\n\nWhen combined into a data set, we get * N=5 IDs receiving 100 mg Q24h x7 * N=3 IDs receiving 50 mg Q12h x 14 * N=2 IDs receiving 200 mg Q48h x 3\n\ndata <- as_data_set(e1,e2,e3)\n\ndata\n\n.    ID time cmt evid amt ii addl\n. 1   1    0   1    1 100 24    6\n. 2   2    0   1    1 100 24    6\n. 3   3    0   1    1 100 24    6\n. 4   4    0   1    1 100 24    6\n. 5   5    0   1    1 100 24    6\n. 6   6    0   1    1  50 12   13\n. 7   7    0   1    1  50 12   13\n. 8   8    0   1    1  50 12   13\n. 9   9    0   1    1 200 24    2\n. 10 10    0   1    1 200 24    2\n\n\nTo simulate from this data set, we use the data_set function. First, let’s load a population PK model\n\nmod <- mread(\"popex\", modlib())\n\n\nmod %>% data_set(data) %>% mrgsim(end=336) %>% plot(GUT+DV ~  .)"
  },
  {
    "objectID": "init.html",
    "href": "init.html",
    "title": "Set initial conditions",
    "section": "",
    "text": "There are two commonly-used ways to set initial conditions: in $MAIN and in the initial condition list.\n\nlibrary(mrgsolve)\nlibrary(dplyr)\n\n\n\nFor a compartment called CMT, there is a variable available to you called CMT_0 that you can use to set the initial condition of that compartment in $MAIN. For example:\n\ncode <- '\n$PARAM KIN = 200, KOUT = 50\n\n$CMT RESP\n\n$MAIN\nRESP_0 = KIN/KOUT;\n'\n\nThis is the most commonly-used way to set initial conditions: the initial condition for the RESP compartment is set equal to KIN divided by KOUT.\nIf you had a parameter called BASE, you could also write RESP_0 = BASE;.\nIn these examples, we’re using data items from $PARAM. But the initial condition could be set to any numeric value in the model, including individual parameters derived from parameters, covariates, and random effects. Note that you should never declare RESP_0 (e.g. double RESP_0): it just appears for you to use.\n\n\n\nYou can also set initial conditions in the initials list. Most commonly, this means declaring compartments with $INIT rather than $CMT. For example\n\ncode <- '\n$INIT RESP = 4\n'\n\nThis method gets us the same result as the previous example, however the initial condition now is not a derived value, but it is coded as a number.\nAlternatively, you could declare a compartment via $CMT and update later (see next).\nWe can update this value later like this ::: {.cell}\nmod <- mcode(\"init_up\", code)\n\nBuilding init_up ... done.\n\ninit(mod)\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   4     | . ...   .    \n\ninit(mod, RESP=8) %>% init\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   8     | . ...   .    \n\n:::\nThis method is commonly used to set initial conditions in large QSP models where the compartment starts out as some known or assumed steady state value.\n\n\n\nUsing an initial condition to put a starting dose in a compartment is not recommended. Always use a dosing event for that."
  },
  {
    "objectID": "init.html#make-a-model-only-to-examine-init-behavior",
    "href": "init.html#make-a-model-only-to-examine-init-behavior",
    "title": "Set initial conditions",
    "section": "Make a model only to examine init behavior",
    "text": "Make a model only to examine init behavior\nNote: IFLAG is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and mrgsolve does not control the value).\nFor this demo\n\nCompartment A initial condition defaults to 0\nCompartment A initial condition will get set to BASE only if IFLAG  > 0\nCompartment A always stays at the initial condition (the system doesn’t advance)\n\n\ncode <- '\n$PARAM BASE=200, IFLAG = 0\n\n$CMT A\n\n$MAIN\nif(IFLAG > 0) A_0 = BASE;\n\n$ODE dxdt_A = 0;\n'\n\n\nmod <- mcode(\"init_long\",code)\n\nBuilding init_long ... done.\n\ndplot <- function(x) plot(x,ylim=c(0,400))\n\nCheck the initial condition ::: {.cell}\ninit(mod)\n\n\n Model initial conditions (N=1):\n name    value . name    value\n A (1)   0     | . ...   .    \n\n:::\nNote:\n\nWe used $CMT in the model spec; that implies that the base initial condition for A is set to 0\nIn this chunk, the code in $MAIN doesn’t get run because IFLAG is 0\nSo, if we don’t update something in $MAIN the initial condition is as we set it in the base list\n\n\nmod %>% mrgsim %>% dplot\n\n\n\n\nNext, we update the base initial condition for A to 100\nNote:\n\nThe code in $MAIN still doesn’t get run because IFLAG is 0\n\n\nmod %>% init(A = 100) %>% mrgsim %>% dplot\n\n\n\n\nNow, turn on IFLAG\nNote:\n\nNow, that code in $MAIN gets run\nA_0 is set to the value of BASE\n\n\nmod %>% param(IFLAG=1) %>% mrgsim %>% dplot\n\n\n\nmod %>% param(IFLAG=1, BASE=300) %>% mrgsim %>% dplot"
  },
  {
    "objectID": "init.html#example-pkpd-model-with-initial-condition",
    "href": "init.html#example-pkpd-model-with-initial-condition",
    "title": "Set initial conditions",
    "section": "Example PK/PD model with initial condition",
    "text": "Example PK/PD model with initial condition\nJust to be clear, there is no need to set any sort of flag to set the initial condition.\n\ncode <- '\n$PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5\n\n$CMT RESP\n\n$MAIN \nRESP_0 = KIN/KOUT;\n\n$ODE\ndxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP;\n'\n\n\nmod <- mcode(\"init_long2\", code)\n\nBuilding init_long2 ... done.\n\n\nThe initial condition is set to 40 per the values of KIN and KOUT\n\nmod %>% mrgsim %>% plot\n\n\n\n\nEven when we change RESP_0 in R, the calculation in $MAIN gets the final say\n\nmod %>% init(RESP=1E9) %>% mrgsim\n\nModel:  init_long2 \nDim:    25 x 3 \nTime:   0 to 24 \nID:     1 \n    ID time RESP\n1:   1    0   40\n2:   1    1   40\n3:   1    2   40\n4:   1    3   40\n5:   1    4   40\n6:   1    5   40\n7:   1    6   40\n8:   1    7   40"
  },
  {
    "objectID": "init.html#calling-init-will-let-you-check-to-see-what-is-going-on",
    "href": "init.html#calling-init-will-let-you-check-to-see-what-is-going-on",
    "title": "Set initial conditions",
    "section": "Calling init will let you check to see what is going on",
    "text": "Calling init will let you check to see what is going on\n\nIt’s a good idea to get in the habit of doing this when things aren’t clear\ninit first takes the base initial condition list, then calls $MAIN and does any calculation you have in there; so the result is the calculated initials\n\n\ninit(mod)\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   40    | . ...   .    \n\nmod %>% param(KIN=100) %>% init\n\n\n Model initial conditions (N=1):\n name       value . name    value\n RESP (1)   20    | . ...   ."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mrgsolve vignettes",
    "section": "",
    "text": "Content\n\nGet started\nEvent objects\nSet initial conditions\nModel without compartments\nResimulate random effects\nModeled events\nQuick hit demos"
  },
  {
    "objectID": "01-get-started.html",
    "href": "01-get-started.html",
    "title": "Quick Start",
    "section": "",
    "text": "This vignette shows the user how to do their first simulation with mrgsolve.\n\nLoad a model\nAfter loading the package ::: {.cell hash=‘01-get-started_cache/html/unnamed-chunk-4_b3ab3afe12c1f988a4956ae79d8e9859’}\nlibrary(mrgsolve)\n:::\nwe’ll use the mread() function to read, parse, compile and load a model out of the internal model library. Try calling the modlib function (modlib()) and see that the path to the installed package is returned, pointing to a directory of pre-coded models. These models are good to try when learning mrgsolve.\nFor this first example, we’re using a one compartment model (called pk1 in the model library)\n\nmod <- modlib(\"pk1\")\n\nOnce we create the model object (mod) we can extract certain information about the model. For example, get an overview\n\nmod\n\n. \n. \n. -----------------  source: pk1.cpp  -----------------\n. \n.   project: /Users/kyleb/Rli...gsolve/models\n.   shared object: pk1-so-1edd18a809e8 \n. \n.   time:          start: 0 end: 24 delta: 1\n.                  add: <none>\n. \n.   compartments:  EV CENT [2]\n.   parameters:    CL V KA [3]\n.   captures:      CP [1]\n.   omega:         0x0 \n.   sigma:         0x0 \n. \n.   solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n. ------------------------------------------------------\n\n\nOr look at model parameters and their values ::: {.cell hash=‘01-get-started_cache/html/unnamed-chunk-10_b779313bd051ffdcdc70fb04298e5d78’}\nparam(mod)\n\n. \n.  Model parameters (N=3):\n.  name value . name value\n.  CL   1     | V    20   \n.  KA   1     | .    .\n\n:::\nWe’ll see in the section below how to run a simulation from this model. But first, let’s create a dosing intervention to use with this model.\n\n\nCreate an intervention\nThe simplest way to create an intervention is to use an event object. This is just a simple expression of one or more model interventions (most frequently doses)\n\nevnt <- ev(amt = 100, ii = 24, addl = 9)\n\n\nevnt\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    9   1    1\n\n\nWe’ll see in other vignettes how to create more-complicated events as well as how to create larger data sets with many individuals in them.\nFor now, the event object is just an intervention that we can combine with a model.\n\n\nSimulate\nTo simulate, use the mrgsim() function. ::: {.cell hash=‘01-get-started_cache/html/unnamed-chunk-16_6ef0a0d49848cdb0a1eb27b9a8c3e4e5’}\nout <- mod %>% ev(evnt) %>% mrgsim(end = 480, delta = 0.1)\n:::\nWe use a pipe sequence here (%>%) to pass the model object (mod) into the event function (ev()) where we attach the dosing intervention, and that result gets passed into the simulation function. The result of the simulation function is essentially a data frame of simulated values\n\nout\n\n. Model:  pk1 \n. Dim:    4802 x 5 \n. Time:   0 to 480 \n. ID:     1 \n.     ID time     EV   CENT     CP\n. 1:   1  0.0   0.00  0.000 0.0000\n. 2:   1  0.0 100.00  0.000 0.0000\n. 3:   1  0.1  90.48  9.492 0.4746\n. 4:   1  0.2  81.87 18.034 0.9017\n. 5:   1  0.3  74.08 25.715 1.2858\n. 6:   1  0.4  67.03 32.619 1.6309\n. 7:   1  0.5  60.65 38.819 1.9409\n. 8:   1  0.6  54.88 44.383 2.2191\n\n\n\n\nPlot\nmrgsolve comes with several different functions for processing output. One simple function is a plot method that will generate a plot of what was just simulated\n\nplot(out)"
  },
  {
    "objectID": "dollar_pred.html",
    "href": "dollar_pred.html",
    "title": "Models without compartments ($PRED)",
    "section": "",
    "text": "This vignette introduces a new formal code block for writing models where there are no compartments. The block is named after the analogous NONMEM block called $PRED. This functionality has always been possible with mrgsolve, but only now is there a code block dedicated to these models. Also, a relaxed set of data set constraints have been put in place when these types of models are invoked.\n\nStatus\nThe functionality in this vignette can only be access from the GitHub version. We will update this vignette once these features are rolled into a release on CRAN.\n\n\nExample model\nAs a most-basic model, we look at the pred1 model in modlib()\n\nlibrary(mrgsolve)\nmod <- modlib(\"pred1\")\n\nThe model code is ::: {.cell}\n$PROB\nAn example model expressed in closed form\n$PARAM B = -1, beta0 = 100, beta1 = 0.1\n$OMEGA 2 0.3\n$PRED\ndouble beta0i = beta0 + ETA(1);\ndouble beta1i = beta1*exp(ETA(2));\ncapture Y = beta0i + beta1i*B;\n:::\nThis is a random-intercept, random slope linear model. Like other models in mrgsolve, you can write parameters ($PARAM), and random effects ($OMEGA). But the model is actually written in $PRED.\nWhen mrgsolve finds $PRED, it will generate an error if it also finds $MAIN, $TABLE, or $ODE. However, the code that gets entered into $PRED would function exactly as if you put it in $TABLE.\nIn the example model, the response is a function of the parameter B, so we’ll generate an input data set with some values of B\n\nlibrary(dplyr)\ndata <- data_frame(ID = 1, B = exp(rnorm(100, 0,2)))\n\nWarning: `data_frame()` was deprecated in tibble 1.1.0.\nPlease use `tibble()` instead.\nThis warning is displayed once every 8 hours.\nCall `lifecycle::last_lifecycle_warnings()` to see where this warning was generated.\n\nhead(data)\n\n# A tibble: 6 × 2\n     ID        B\n  <dbl>    <dbl>\n1     1  0.00271\n2     1  1.87   \n3     1  0.189  \n4     1  1.09   \n5     1  0.308  \n6     1 15.3    \n\n\n\nout <- mrgsim_d(mod,data,carry.out=\"B\")\n\nplot(out, Y~B)\n\n\n\n\nLike other models, we can simulate from a population\n\nlibrary(purrr)\nset.seed(223)\ndf <- map_df(1:30, function(i) data_frame(ID = i, B = seq(0,30,1)))\n\nhead(df)\n\n# A tibble: 6 × 2\n     ID     B\n  <int> <dbl>\n1     1     0\n2     1     1\n3     1     2\n4     1     3\n5     1     4\n6     1     5\n\nmod %>% \n  data_set(df) %>% \n  mrgsim(carry.out=\"B\") %>%\n  plot(Y ~ B)\n\n\n\n\n\n\nPK/PD Model\nHere is an implementation of a PK/PD model using $PRED\nIn this model\n\nCalculate CL as a function of WT and a random effect\nDerive AUC from CL and DOSE\nThe response (Y) is a calculated from AUC and the Emax model parameters\n\n\ncode <- '\n$PARAM TVCL = 1, WT = 70, AUC50 = 20, DOSE = 100, E0 = 35, EMAX = 2.4\n\n$OMEGA 1\n\n$SIGMA 100\n\n$PRED\ndouble CL = TVCL*pow(WT/70,0.75)*exp(ETA(1));\ncapture AUC = DOSE/CL;\ncapture Y = E0*(1+EMAX*AUC/(AUC50+AUC))+EPS(1);\n'\n\n\nmod <- mcode_cache(\"pkpd\", code)\n\nLoading model from cache.\n\n\nTo simulate, look at 50 subjects at each of 5 doses ::: {.cell}\ndata <- \n  expand.idata(DOSE = c(30,50,80,110,200),ID = 1:50) %>% \n  mutate(WT = exp(rnorm(n(),log(80),1)))\n\nhead(data)\n\n  ID DOSE        WT\n1  1   30  59.13254\n2  2   50 317.32739\n3  3   80 242.15746\n4  4  110 170.78136\n5  5  200 248.18054\n6  6   30  51.22012\n\n:::\n\nout <- mrgsim_d(mod,data,carry.out=\"WT,DOSE\") %>% as.data.frame()\n\nhead(out)\n\n  ID time        WT DOSE       AUC         Y\n1  1    0  59.13254   30 231.90852 110.61330\n2  2    0 317.32739   50  36.76051  85.27834\n3  3    0 242.15746   80  36.54808  98.90407\n4  4    0 170.78136  110  23.68354  80.29131\n5  5    0 248.18054  200 331.10229 108.81926\n6  6    0  51.22012   30 251.58373 116.09649\n\n\nPlot the response (Y) versus AUC, colored by dose ::: {.cell}\nlibrary(ggplot2)\n\nggplot(out, aes(AUC,Y,col =factor(DOSE))) + \n  geom_point() + \n  scale_x_continuous(trans = \"log\", breaks = 10^seq(-4,4)) + \n  geom_smooth(aes(AUC,Y),se = FALSE,col=\"darkgrey\") + theme_bw() + \n  scale_color_brewer(palette = \"Set2\", name = \"\") + \n  theme(legend.position = \"top\")\n\n`geom_smooth()` using method = 'loess' and formula 'y ~ x'\n\n\n\n\n:::"
  },
  {
    "objectID": "mevent.html",
    "href": "mevent.html",
    "title": "Modeled events",
    "section": "",
    "text": "In this vignette, we’ll focus on creating a discontinuity in the simulation so that the value of a parameter can change at a specific time that is not necessarily chosen prior to the run time.\n\nConcept: mevent\nThis toy model shows how you can use mevent() to schedule a discontinuity into the simulation. This model doesn’t do anything, but will help us see what parts are in play.\n\n[ MAIN ]\n\n// Part A\nif(NEWIND <=1) double mtime = 1E10;\n\n// Part B\nif(EVID==1) {\n  mtime = TIME + 1.23;\n  self.mevent(mtime, 33);\n}\n\n// Part C\ncapture past  = TIME >= mtime;\n\nIn contrast to the NONMEM MTIME() functionality, we have to do a little more work keeping track of the status of the system. There are multiple ways to organize this. I’m going to show you one way that tries to minimize the amount of this book keeping work.\nIn the first part of [ MAIN ], I will create a variable called mtime and initialize it to some large, arbitrary value. This is the time of the modeled event and we will eventually want to check to see if we are past this time. Initializing to this large .value will ensure we aren’t past mtime when the problem starts. This is Part A.\n\n// Part A\nif(NEWIND <=1 ) capture mtime  = 1E10;\n\nNext, we’ll come up with some condition that will trigger the creation of the future discontinuity. In this example, we’ll check to see when a dose was given and schedule the event 1.23 hours into the future. We keep track of that future time in the mtime variable. That’s Part B.\n\n// Part B\nif(EVID==1) {\n  mtime = TIME + 1.23;\n  self.mevent(mtime, 33);\n}\n\nThere is a function in the self object called mevent() that takes two arguments: first the TIME of the event and second the EVID. In this example, we create a record with EVID of 33 at 1.23 hours after the dose. We pick EVID 33 as a unique flag for this event. But beyond that, the specific value isn’t important.\nThe final piece of this toy model is to check to see if the system has been advanced past mtime.\n\n// Part C\ncapture past = TIME >= mtime;\n\nTo put it all back together\n\n[ MAIN ]\n\n// Part A\nif(NEWIND <=1) double mtime = 1E10;\n\n// Part B\nif(EVID==1) {\n  mtime = TIME + 1.23;\n  self.mevent(mtime, 33);\n}\n\n// Part C\ncapture past  = TIME >= mtime;\n\nNow run this model to check the output. We want to see when the past variable switches to 1.\n\nlibrary(mrgsolve)\n\nmod <- mread_cache(\"mevent_0\")\n\n\nmod %>% ev(amt = 1, cmt=0) %>% mrgsim()\n\nModel:  mevent_0 \nDim:    26 x 3 \nTime:   0 to 24 \nID:     1 \n    ID time past\n1:   1    0    0\n2:   1    0    0\n3:   1    1    0\n4:   1    2    1\n5:   1    3    1\n6:   1    4    1\n7:   1    5    1\n8:   1    6    1\n\n\nThe switch happens at time 1.23, between time 1 and time 2. You can use the mrgsolve::report() function to check that the EVID==33 event happens at the proper time (not able to display this inside the vignette). This is an optional Part D.\n\n// Part D\nif(EVID==33) mrgsolve::report(TIME);  \n\nSo we can check that the model is actually stopping at this point (TIME 1.23). Note that this time is not included in the simulation time grid.\n\n\nApplication: time-varying KA\nWe can put this principle into action with a PK model where KA changes (increases) some time after the administration of the dose. Here’s the model\n\n[ PARAM ] CL = 1.5, V = 8, KA1 = 0.2, KA2 = 3.8\n\n[ PKMODEL ] cmt = \"GUT CENT\", depot = TRUE\n\n[ MAIN ]\n\nif(NEWIND <=1) double mtime = 1E10;\n\nif(EVID==1) {\n  mtime = TIME + 1.23;\n  self.mevent(mtime, 33);\n}\n\ncapture KA = TIME >= mtime ? KA2 : KA1;\n\nWe have pretty much the same setup as the toy example above, but now including a PK model where KA changes from KA1 to KA2 at mtime\n\nmod <- mread(\"mevent_1\", req = \"CENT\", end = 12, delta = 0.1)\n\nWhen we simulate, we see KA increase at the change point as well as the rate of increase in the CENT compartment ::: {.cell}\nmod %>% \n  ev(amt = 100) %>%\n  mrgsim() %>% \n  plot()\n\n\n\n:::\nWe can also run this model for several doses ::: {.cell}\nmod %>% \n  ev(amt = 100, ii = 12, total = 4) %>%\n  mrgsim(end = 48) %>% \n  plot()\n\n\n\n:::"
  },
  {
    "objectID": "quick.html",
    "href": "quick.html",
    "title": "Quick hit demos",
    "section": "",
    "text": "library(mrgsolve)\nlibrary(dplyr)\n\n\n$ operator for model object gets the parameter value\nIf our model parameters are ::: {.cell}\nmod <- mrgsolve:::house()\n\nparam(mod)\n\n\n Model parameters (N=14):\n name value . name  value\n CL   1     | SEX   0    \n D1   2     | SEXCL 0.7  \n F1   1     | SEXVC 0.85 \n IC50 10    | VC    20   \n KA   1.2   | WT    70   \n KIN  100   | WTCL  0.75 \n KOUT 2     | WTVC  1    \n\n:::\nwe can pick a parameter value with ::: {.cell}\nmod$CL\n\n[1] 1\n\nmod$WT\n\n[1] 70\n\n:::\nOr slice off multiple parameters ::: {.cell}\ni_want <- c(\"CL\", \"WT\")\nmod[i_want]\n\n$CL\n[1] 1\n\n$WT\n[1] 70\n\n:::\n\n\nModel names\nFor programming with a model object, we can extract the names ::: {.cell}\nnames(mod)\n\n$param\n [1] \"CL\"    \"VC\"    \"KA\"    \"F1\"    \"D1\"    \"WT\"    \"SEX\"   \"WTCL\"  \"WTVC\" \n[10] \"SEXCL\" \"SEXVC\" \"KIN\"   \"KOUT\"  \"IC50\" \n\n$init\n[1] \"GUT\"  \"CENT\" \"RESP\"\n\n$capture\n[1] \"DV\" \"CP\"\n\n$omega\n[1] \"...\"\n\n$sigma\n[1] \"...\"\n\n$omega_labels\n$omega_labels[[1]]\n[1] \"ECL\"   \"EVC\"   \"EKA\"   \"EKOUT\"\n\n\n$sigma_labels\n$sigma_labels[[1]]\n[1] \"EXPO\"\n\n:::\nor get all of the model elements in a list (output not shown)\n\nmy_model <- as.list(mod)\n\n\n\nZero all random effect variances on the fly\nIf your model has random effects, you can easily and temporarily zero them out.\n\nmod <- modlib(\"popex\") %>% update(end=96) %>% Req(DV,CL,V)\n\nLoading model from cache.\n\nomat(mod)\n\n$...\n      [,1] [,2] [,3]\nECL:   0.3  0.0  0.0\nEV:    0.0  0.1  0.0\nEKA:   0.0  0.0  0.5\n\n\nIt is easy to simulate either with or without the random effects in the simulation: this change can be made on the fly.\nUse zero_re to make all random effect variances zero ::: {.cell}\nmod %>% zero_re %>% omat\n\n$...\n      [,1] [,2] [,3]\nECL:     0    0    0\nEV:      0    0    0\nEKA:     0    0    0\n\n:::\nBy default, both OMEGA and SIGMA are zeroed. Check the arguments for zero_re to see how to selectively zero OMEGA or SIGMA.\nCompare the population output\n\nmod %>% ev(amt=100) %>% mrgsim(nid=20) %>% plot\n\n\n\n\nwith\n\nmod %>% ev(amt=100) %>% zero_re %>% mrgsim(nid=20) %>% plot\n\n\n\n\n\n\nPlot formulae\nWe commonly plot simulated output with a special plot method. By default, you get all compartments and output variables in the plot.\n\nmod <- mrgsolve:::house() %>% ev(amt=100)\nmod %>% mrgsim %>% plot\n\n\n\n\nThe plot can be customized with a formula selecting variables to plot. Other arguments\nto lattice::xyplot can be passed as well. ::: {.cell}\nmod %>% mrgsim %>% plot(CP+RESP ~ time, lty=2, col=\"firebrick\")\n\n\n\n:::\n\n\nGet a data frame of simulated data\nBy default mrgsolve returns an object of simulated data (and other stuff) ::: {.cell}\nout <- mrgsim(mod)\n\nclass(out)\n\n[1] \"mrgsims\"\nattr(,\"package\")\n[1] \"mrgsolve\"\n\n:::\nBut you can get a data frame with ::: {.cell}\nout <- mrgsim_df(mod)\n\nclass(out)\n\n[1] \"data.frame\"\n\n:::\nor\n\nout <- mrgsim(mod,output=\"df\")\n\nout <- mrgsim(mod) %>% as_tibble()"
  }
]